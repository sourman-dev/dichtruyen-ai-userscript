This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  app.d.ts
  button.ts
  history.ts
  main.ts
  modals.ts
  style.css
  typescript.svg
  utils.ts
  vite-env.d.ts
  vite.svg
.gitignore
package.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app.d.ts">
export interface HistoryItem {
  url: string;
  title: string;
  timestamp: number;
}

export interface aiProvider{
  name: string;
  modelName: string;
  apiKey: string | null;
  temperature: number;
  selected: boolean;
}

export interface AppState {
    settings: {
      systemPrompt?: string;
      userPrompt?: string;
      aiProvider: aiProvider[];
    };
    history: HistoryItem[];
    readerView?: {
      backgroundColor?: string;
      fontFamily?: string;
      lineHeight?: string;
      fontSize?: number;
    };
}
</file>

<file path="src/button.ts">
import van from "vanjs-core";
import { Readability } from "@mozilla/readability";
import { textVide } from "text-vide";
import { settingsModal, historyModal } from "./modals";
import type { AppState } from "./app.d";
import { db, getFromHistory } from "./history";
import { translateFunc } from "./utils";
const { span, button } = van.tags;

class BottomBar extends HTMLElement {
  private appState: AppState;

  constructor(appState: AppState) {
    super();
    this.attachShadow({ mode: "open" });
    this.appState = appState;
  }

  private updateStyle() {
    if (!this.shadowRoot) return;

    const style = document.createElement("style");
    style.textContent = `
      :host {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 9999;
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        pointer-events: none;
      }
      .bottom-bar {
        background-color: white;
        box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
        padding: 10px;
        display: flex;
        justify-content: center;
        gap: 20px;
        width: 100%;
        height: auto;
        min-height: 60px;
        box-sizing: border-box;
        -webkit-overflow-scrolling: touch;
        pointer-events: auto;
        isolation: isolate;
      }
      .icon-button {
        background: none;
        border: none;
        cursor: pointer;
        padding: 8px;
        border-radius: 50%;
        background-color: white;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        touch-action: manipulation;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        z-index: 1;
      }
      .icon {
        display: inline-block;
        width: 24px;
        height: 24px;
        background-size: contain;
        background-repeat: no-repeat;
        vertical-align: middle;
      }
    `;
    this.shadowRoot.appendChild(style);
  }

  connectedCallback() {
    this.updateStyle();
    if (this.appState) {
      van.derive(() => {
        const readerView = this.appState.readerView;
        if (readerView) {
          this.updateStyle();
        }
      });
    }

    // Add click event listener to shadowRoot to prevent event propagation
    if (this.shadowRoot) {
      this.shadowRoot.addEventListener(
        "click",
        (e) => {
          const target = e.target as HTMLElement;
          if (!target.closest(".icon-button")) {
            e.stopPropagation();
            e.stopImmediatePropagation();
          }
        },
        true
      );
    }
  }
}

customElements.define("bottom-bar", BottomBar);

class ReaderView extends HTMLElement {
  private appState: AppState;
  private styleElement: HTMLStyleElement;
  private contentContainer: HTMLDivElement;

  constructor(appState: AppState) {
    super();
    this.attachShadow({ mode: "open" });
    this.appState = appState;
    this.styleElement = document.createElement("style");
    this.contentContainer = document.createElement("div");
    this.contentContainer.className = "content-container";
    this.shadowRoot?.appendChild(this.styleElement);
    this.shadowRoot?.appendChild(this.contentContainer);
    // this.updateStyle();
  }

  updateStyle(appState: AppState) {
    if (!this.shadowRoot) return;
    this.appState = appState;
    // console.log("updateStyle", this.appState);
    const backgroundColor =
      this.appState?.readerView?.backgroundColor || "#F4F4F4";
    const fontFamily = this.appState?.readerView?.fontFamily || "system-ui";
    const lineHeight = this.appState?.readerView?.lineHeight || "1.6";
    const fontSize = this.appState?.readerView?.fontSize || 16;
    const textColor = backgroundColor === "black" ? "white" : "#2B2B2B";

    this.styleElement.textContent = `
      :host {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 60px;
        background: ${backgroundColor};
        color: ${textColor};
        z-index: 9998;
        padding: 5px 5px 5px 5px;
        overflow-y: auto;
        font-family: ${fontFamily}, -apple-system, sans-serif;
        line-height: ${lineHeight};
        font-size: ${fontSize}px;
        font-weight: 400;
        max-width: 100%;
        height: calc(100vh - 60px);
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .content-container {
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        box-sizing: border-box;
      }
      .article-title {
        font-size: 1.5em;
        font-weight: bold;
        margin-bottom: 1em;
        text-align: center;
      }
    `;
  }

  setContent({ content, title }: { content: string; title: string }) {
    if (!this.shadowRoot) return;

    const titleElement = document.createElement("h1");
    titleElement.className = "article-title";
    titleElement.textContent = title;

    const contentElement = document.createElement("div");
    contentElement.className = "article-content";
    contentElement.style.whiteSpace = "pre-wrap";
    contentElement.innerHTML = content;

    this.contentContainer.innerHTML = "";
    this.contentContainer.appendChild(titleElement);
    this.contentContainer.appendChild(contentElement);

    return contentElement;
  }

  connectedCallback() {
    if (this.appState) {
      van.derive(() => {
        const readerView = this.appState.readerView;
        if (readerView) {
          this.updateStyle(this.appState);
          const contentElement =
            this.shadowRoot?.querySelector(".article-content");
          if (contentElement instanceof HTMLElement) {
            contentElement.style.whiteSpace = "pre-wrap";
          }
        }
      });
    }
  }
}

customElements.define("reader-view", ReaderView);

const toggleReaderMode = async (appState: AppState) => {
  const existingReader = document.querySelector("reader-view");
  if (existingReader) {
    existingReader.remove();
    return;
  }

  const documentClone = document.cloneNode(true) as Document;
  const article = new Readability(documentClone).parse();

  if (article) {
    const readerView = document.createElement("reader-view") as ReaderView;
    document.body.appendChild(readerView);
    readerView.updateStyle(appState);
    const translationContainer = (readerView as any).setContent({
      content: "Translating...",
      title: article.title || "",
    });

    if (translationContainer) {
      let accumulatedText = "";

      // Check if translation exists in cache
      const url = window.location.href;

      const historyItem = await getFromHistory(url);
      let isNeedTranslate = true;
      if (historyItem) {
        const cachedTranslation = await db.get(`translation:${url}`);
        if (cachedTranslation) {
          translationContainer.innerHTML = textVide(cachedTranslation);
          isNeedTranslate = false;
        }
      }
      if (isNeedTranslate) {
        await translateFunc(
          article.textContent || "",
          (chunk) => {
            accumulatedText += chunk;
            translationContainer.innerHTML = textVide(accumulatedText);
          },
          appState
        );
      }
    }
  }
};

export const TranslateButton = (appState: AppState) => {
  const bottomBar = document.createElement("bottom-bar");
  const shadowRoot = bottomBar.shadowRoot;

  if (shadowRoot) {
    const container = document.createElement("div");
    container.className = "bottom-bar";

    const createIconButton = (icon: string, onClick: () => void) => {
      return button(
        {
          onclick: onClick,
          class: "icon-button",
        },
        span({
          class: "icon",
          style: `background-image: url('data:image/svg+xml;utf8,${icon}');`,
        })
      );
    };

    const infoIcon =
      '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>';
    const translateIcon =
      '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/></svg>';
    const configIcon =
      '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>';

    van.add(
      container,
      createIconButton(infoIcon, () => historyModal(appState)),
      createIconButton(translateIcon, () => toggleReaderMode(appState)),
      createIconButton(configIcon, () => settingsModal(appState))
    );

    shadowRoot.appendChild(container);
  }

  return bottomBar;
};
</file>

<file path="src/history.ts">
import { set, get, del, createStore } from 'idb-keyval';
import type { AppState, HistoryItem } from './app';

export const useStore = createStore('doctruyenCached', 'doctruyen-store');

export const db = {
  get: async (key: string) => {
    return await get(key, useStore);
  },
  set: async (key: string, value: any) => {
    return await set(key, value, useStore);
  },
  del: async (key: string) => {
    return await del(key, useStore);
  },
};

export const addToHistory = async (appState: AppState, url: string, title: string, translated: string) => {
  const newItem: HistoryItem = {
    url,
    title,
    timestamp: Date.now()
  };

  // Update app state history (keep only last 10 items)
  appState.history = [newItem, ...appState.history].slice(0, 10);

  // Store translation in IndexedDB
  try {
    await db.set(`history:${url}`, newItem);
    await db.set(`translation:${url}`, translated);
  } catch (error) {
    console.error('Failed to save to history:', error);
  }
};

export const getFromHistory = async (url: string) => {
  try {
    return await db.get(`history:${url}`);
  } catch (error) {
    console.error('Failed to get from history:', error);
    return null;
  }
};

export const deleteHistoryItem = async (appState: AppState, url: string) => {
  try {
    await db.del(`history:${url}`);
    await db.del(`translation:${url}`);
    appState.history = appState.history.filter((item) => item.url !== url);
    return await getFromHistory(url);
  } catch (error) {
    console.error('Failed to delete history item:', error);
    throw error;
  }
};

export const clearHistory = async (appState: AppState) => {
  appState.history = [];
  try {
    const keys = await db.get('historyKeys') || [];
    for (const key of keys) {
      await db.del(key);
    }
    await db.del('historyKeys');
  } catch (error) {
    console.error('Failed to clear history:', error);
  }
};
</file>

<file path="src/main.ts">
import * as vanX from "vanjs-ext";
import van from "vanjs-core";
import { TranslateButton } from "./button";
import { getSystemPrompt } from "./utils";
const APP_VERSION = "0.0.1";

const DEFAULT_SETTINGS = JSON.stringify({
  version: APP_VERSION,
  settings: {
    userPrompt: "",
    aiProvider: [
      {
        name: "Google",
        modelName: "gemini-2.0-flash",
        apiKey: null,
        temperature: 0.0,
        selected: true
      },
      {
        name: "Qwen",
        modelName: "qwen-max-latest",
        apiKey: null,
        temperature: 0.0,
        selected: false
      },
    ],
  },
  readerView: {
    backgroundColor: "#F4F4F4",
    fontFamily: "system-ui",
    lineHeight: "1.6",
    fontSize: 16,
    bionicReading: false,
  },
  history: [],
});

const mergeConfigs = (oldConfig: any, defaultConfig: any) => {
  const merged = { ...defaultConfig };

  // Merge settings while preserving user customizations
  if (oldConfig.settings) {
    merged.settings = {
      ...defaultConfig.settings,
      ...oldConfig.settings,
    };
  }

  // Merge readerView settings
  if (oldConfig.readerView) {
    merged.readerView = {
      ...defaultConfig.readerView,
      ...oldConfig.readerView,
    };
  }

  // Preserve history
  if (oldConfig.history) {
    merged.history = oldConfig.history;
  }

  // Update version
  merged.version = APP_VERSION;

  return merged;
};

const savedState = localStorage.getItem("doctruyenState");
let initialState;

if (savedState) {
  const parsedState = JSON.parse(savedState);
  if (!parsedState.version || parsedState.version !== APP_VERSION) {
    // Version mismatch - merge configurations
    try {
      const defaultSettings = JSON.parse(DEFAULT_SETTINGS);
      defaultSettings.settings.systemPrompt = await getSystemPrompt();
      initialState = mergeConfigs(parsedState, defaultSettings);
    } catch (error) {
      console.error("Failed to fetch remote prompt:", error);
      initialState = mergeConfigs(parsedState, JSON.parse(DEFAULT_SETTINGS));
    }
  } else {
    initialState = parsedState;
  }
} else {
  const defaultSettings = JSON.parse(DEFAULT_SETTINGS);
  defaultSettings.settings.systemPrompt = await getSystemPrompt();
  initialState = defaultSettings;
}

const appState = vanX.reactive(initialState);

van.derive(() =>
  localStorage.setItem("doctruyenState", JSON.stringify(vanX.compact(appState)))
);

document.body.append(TranslateButton(appState));
</file>

<file path="src/modals.ts">
import van from "vanjs-core";
import { Tabs, Await } from "vanjs-ui";
import type { State } from "vanjs-core";
import * as vanX from "vanjs-ext";
import { AppState, aiProvider } from "./app";
import { deleteHistoryItem, getFromHistory } from "./history";

const { button, div, input, label, a, span } = van.tags;

class SettingsModalElement extends HTMLElement {
  // private closed: State<boolean> = van.state(false);
  private tempSettings: any;
  private appState!: AppState;

  constructor() {
    super();
    this.attachShadow({ mode: "open" });
  }

  connectedCallback() {
    if (this.shadowRoot) {
      // Add click event listener to prevent event propagation
      this.shadowRoot.addEventListener(
        "click",
        (e) => {
          const target = e.target as HTMLElement;
          if (!target.closest(".modal-content")) {
            e.stopPropagation();
            e.stopImmediatePropagation();
          }
        },
        true
      );

      const style = document.createElement("style");
      style.textContent = `
        :host {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          z-index: 9999;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .modal-content {
          padding: clamp(10px, 3vw, 20px);
          width: clamp(280px, 90vw, 600px);
          max-height: calc(100vh - 20px);
          margin: clamp(5px, 2vw, 10px);
          overflow-y: auto;
          background: white;
          border-radius: 8px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .input-group {
          margin-bottom: clamp(10px, 3vw, 15px);
        }
        .input-label {
          display: block;
          margin-bottom: 5px;
        }
        .input-field {
          width: 100%;
          padding: clamp(6px, 2vw, 8px);
          border: 1px solid #ddd;
          border-radius: 4px;
        }
        .textarea-field {
          min-height: clamp(150px, 30vh, 200px);
        }
        .button-group {
          display: flex;
          justify-content: flex-end;
          gap: clamp(6px, 2vw, 10px);
          margin-top: clamp(15px, 4vw, 20px);
        }
        .button {
          padding: clamp(6px, 2vw, 8px) clamp(12px, 3vw, 16px);
          border-radius: 4px;
          cursor: pointer;
        }
        .cancel-button {
          border: 1px solid #ddd;
          background: white;
        }
        .save-button {
          background: #4CAF50;
          color: white;
          border: none;
        }
        .font-size-controls {
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .icon-button {
          background: none;
          border: 1px solid #ddd;
          border-radius: 4px;
          padding: 4px 12px;
          cursor: pointer;
          font-size: 18px;
        }
        .icon-button:hover {
          background: #f5f5f5;
        }
      `;
      this.shadowRoot.appendChild(style);
    }
  }

  private availableFonts: string[] = [];
  private availableColors: { [key: string]: string }[] = [];
  private avaibleLineHeights: string[] = ["1.6", "1", "1.2", "1.4", "1.8", "2"];
  async initialize(appState: AppState) {
    this.appState = appState;
    // this.closed = van.state(false);

    // Load available fonts
    // const { detectAvailableFonts } = await import('./fonts');
    this.availableFonts = [
      "Palatino Linotype",
      "Bookerly",
      "Segoe UI",
      "Patrick Hand",
      "Times New Roman",
      "Verdana",
      "Tahoma",
    ];
    this.availableColors = [
      {
        name: "Light Gray",
        value: "#F4F4F4",
      },
      {
        name: "Light Blue",
        value: "#E8EBEE",
      },
      {
        name: "Deep Blue",
        value: "#E1E4F2",
      },
      {
        name: "Light Yellow",
        value: "#F4F4E3",
      },
      {
        name: "Sepia",
        value: "#EAE4D3",
      },
      {
        name: "Deep Yellow",
        value: "#FAFAC8",
      },
      {
        name: "Dark",
        value: "black",
      },
    ];
    const savedProvider = appState.settings.aiProvider.find(p => p.selected)  
    this.tempSettings = vanX.reactive({
      systemPrompt: appState.settings.systemPrompt || "",
      userPrompt: appState.settings.userPrompt || "",
      provider: savedProvider?.name || "Google",
      apiKey: savedProvider?.apiKey || "",
      modelName: savedProvider?.modelName || "gemini-2.0-flash",
      temperature: savedProvider?.temperature || 0.0,
      backgroundColor: appState.readerView?.backgroundColor || "#F4F4F4",
      fontFamily: appState.readerView?.fontFamily || "system-ui",
      lineHeight: appState.readerView?.lineHeight || "1.6",
      fontSize: appState.readerView?.fontSize || 16,
    });
    // console.log(this.tempSettings);
    this.render();
  }

  private handleSave = () => {
    this.appState.settings = {
      ...this.appState.settings,
      systemPrompt: this.tempSettings.systemPrompt,
      userPrompt: this.tempSettings.userPrompt,
      aiProvider: this.appState.settings.aiProvider.map((provider: aiProvider) => ({
        ...provider,
        selected: provider.name === this.tempSettings.provider,
        apiKey: provider.name === this.tempSettings.provider ? this.tempSettings.apiKey : provider.apiKey,
        modelName: provider.name === this.tempSettings.provider ? this.tempSettings.modelName : provider.modelName,
        temperature: provider.name === this.tempSettings.provider ? this.tempSettings.temperature : provider.temperature
      })) as aiProvider[],
    };

    this.appState.readerView = {
      backgroundColor: this.tempSettings.backgroundColor,
      fontFamily: this.tempSettings.fontFamily,
      lineHeight: this.tempSettings.lineHeight,
      fontSize: this.tempSettings.fontSize,
    };
    this.remove();
  };

  private createInput = (
    label1: string,
    value: State<string | number>,
    onChange: (val: string) => void,
    options?: { type?: "input" | "textarea"; readonly?: boolean }
  ) => {
    const inputProps = {
      value,
      onchange: (e: Event) => onChange((e.target as HTMLInputElement).value),
      class: `input-field ${
        options?.type === "textarea" ? "textarea-field" : ""
      }`,
    } as any;

    if (options?.readonly) {
      inputProps["readonly"] = true;
    }

    return div(
      { class: "input-group" },
      label({ class: "input-label" }, label1),
      options?.type === "textarea"
        ? van.tags.textarea(inputProps)
        : input(inputProps)
    );
  };

  private render() {
    if (this.shadowRoot) {
      let currentTab = van.state("Display");
        
      // console.log(this.appState?.readerView?.backgroundColor, this.tempSettings.backgroundColor)
      const content = div(
        { class: "modal-content" },
        Tabs(
          {
            activeTab: currentTab,
            style: "width: 100%;",
            tabButtonActiveColor: "#F44336",
            tabButtonBorderStyle: "none",
            tabButtonRowStyleOverrides: {
              "padding-left": "clamp(8px, 2vw, 12px)",
              "border-bottom": "1px solid red",
            },
          },
          {
            Display: div(
              div(
                { class: "input-group" },
                label({ class: "input-label" }, "Background Color"),
                van.tags.select(
                  {
                    class: "input-field",
                    onchange: (e) =>
                      (this.tempSettings.backgroundColor = (
                        e.target as HTMLSelectElement
                      ).value),
                  },
                  this.availableColors.map((color) =>
                    van.tags.option(
                      {
                        value: color.value,
                        selected:
                          this.appState?.readerView?.backgroundColor ===
                          color.value,
                      },
                      color.name
                    )
                  )
                )
              ),
              div(
                { class: "input-group" },
                label({ class: "input-label" }, "Font Family"),
                van.tags.select(
                  {
                    class: "input-field",
                    onchange: (e) =>
                      (this.tempSettings.fontFamily = (
                        e.target as HTMLSelectElement
                      ).value),
                  },
                  this.availableFonts.map((font) =>
                    van.tags.option(
                      {
                        value: font,
                        selected:
                          this.appState?.readerView?.fontFamily === font,
                      },
                      font
                    )
                  )
                )
              ),
              div(
                { class: "input-group" },
                label({ class: "input-label" }, "Line Height"),
                van.tags.select(
                  {
                    class: "input-field",
                    onchange: (e) =>
                      (this.tempSettings.lineHeight = (
                        e.target as HTMLSelectElement
                      ).value),
                  },
                  this.avaibleLineHeights.map((lineHeight) =>
                    van.tags.option(
                      {
                        value: lineHeight,
                        selected:
                          this.appState?.readerView?.lineHeight === lineHeight,
                      },
                      lineHeight
                    )
                  )
                )
              ),
              div(
                { class: "input-group" },
                label({ class: "input-label" }, "Font Size"),
                div(
                  { class: "font-size-controls" },
                  button(
                    {
                      onclick: () =>
                        (this.tempSettings.fontSize =
                          (this.tempSettings.fontSize || 16) - 2),
                      class: "icon-button",
                    },
                    "−"
                  ),
                  span(
                    { style: "margin: 0 10px;" },
                    () => `${this.tempSettings.fontSize || 16}px`
                  ),
                  button(
                    {
                      onclick: () =>
                        (this.tempSettings.fontSize =
                          (this.tempSettings.fontSize || 16) + 2),
                      class: "icon-button",
                    },
                    "+"
                  )
                )
              )
            ),
            Prompt: div(
              this.createInput(
                "System Prompt",
                this.tempSettings.systemPrompt as any,
                (val) => (this.tempSettings.systemPrompt = val),
                { type: "textarea"}
              ),
              this.createInput(
                "User Prompt (Gắn kèm vào bên dưới System Prompt)",
                this.tempSettings.userPrompt as any,
                (val) => (this.tempSettings.userPrompt = val),
                { type: "textarea" }
              )
            ),
            AI: div(
              div(
                { class: "input-group" },
                label({ class: "input-label" }, "Provider"),
                van.tags.select(
                  {
                    class: "input-field",
                    onchange: (e) => {
                      
                      const getProvider = this.appState.settings.aiProvider.find(p => p.name === (e.target as HTMLSelectElement).value);
                      console.info("change provider", getProvider?.name);
                      this.tempSettings.provider = getProvider?.name || "Google";
                      this.tempSettings.apiKey = getProvider?.apiKey || "";
                      this.tempSettings.modelName = getProvider?.modelName || "gemini-2.0-flash";
                      this.tempSettings.temperature = getProvider?.temperature || 0.0;
                      // if (this.tempSettings.provider === "Google") {
                      //   this.tempSettings.modelName = "gemini-2.0-flash";
                      // } else if (this.tempSettings.provider === "Qwen") {
                      //   this.tempSettings.modelName = "qwen-max-latest";
                      // }
                    },
                  },
                  ["Google", "Qwen"].map((provider) =>
                    van.tags.option(
                      {
                        value: provider,
                        selected: this.tempSettings.provider === provider,
                      },
                      provider
                    )
                  )
                )
              ),
              this.createInput(
                "API Key",
                this.tempSettings.apiKey as any,
                (val) => (this.tempSettings.apiKey = val)
              ),
              this.createInput(
                "Model Name",
                this.tempSettings.modelName as any,
                (val) => (this.tempSettings.modelName = val),
                { type: "input", readonly: true }
              ),
              this.createInput(
                "Temperature",
                this.tempSettings.temperature as any,
                (val) =>
                  (this.tempSettings.temperature = parseFloat(val) || 0.0)
              )
            ),
          }
        ),
        div(
          { class: "button-group" },
          button(
            {
              onclick: () => this.remove(),
              class: "button cancel-button",
            },
            "Cancel"
          ),
          button(
            {
              onclick: this.handleSave,
              class: "button save-button",
            },
            "Save"
          )
        )
      );

      this.shadowRoot.appendChild(content);
    }
  }
}

class HistoryModalElement extends HTMLElement {
  private closed: State<boolean> = van.state(false);
  private currentHistory: State<any> = van.state(null);
  private appState!: AppState;

  constructor() {
    super();
    this.attachShadow({ mode: "open" });
  }

  disconnectedCallback() {
    this.closed.val = true;
  }

  connectedCallback() {
    if (this.shadowRoot) {
      // Add click event listener to prevent event propagation
      this.shadowRoot.addEventListener(
        "click",
        (e) => {
          const target = e.target as HTMLElement;
          if (!target.closest(".modal-content")) {
            e.stopPropagation();
            e.stopImmediatePropagation();
          }
        },
        true
      );

      const style = document.createElement("style");
      style.textContent = `
        :host {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          z-index: 9999;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .modal-content {
          padding: clamp(10px, 3vw, 20px);
          width: clamp(280px, 90vw, 600px);
          max-height: calc(100vh - clamp(80px, 15vh, 120px));
          margin: clamp(5px, 2vw, 10px) auto;
          overflow-y: auto;
          background: white;
          border-radius: 8px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .title {
          font-size: clamp(16px, 2.5vw, 18px);
          font-weight: bold;
          margin-bottom: clamp(10px, 2vw, 15px);
        }
        .history-item {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 8px;
          border-bottom: 1px solid #eee;
        }
        .history-link {
          text-decoration: none;
          color: #2196F3;
          flex: 1;
        }
        .delete-button {
          background: none;
          border: none;
          cursor: pointer;
          padding: 4px;
        }
        .button-group {
          display: flex;
          justify-content: flex-end;
          margin-top: 20px;
        }
        .cancel-button {
          padding: 8px 16px;
          border: 1px solid #ddd;
          border-radius: 4px;
          cursor: pointer;
          background: white;
        }
      `;
      this.shadowRoot.appendChild(style);
    }
  }

  initialize(appState: AppState) {
    this.appState = appState;
    this.closed = van.state(false);
    const currentUrl = window.location.href;
    this.currentHistory = van.state(getFromHistory(currentUrl));

    this.render();
  }

  private handleDeleteHistoryItem = async (url: string) => {
    try {
      await deleteHistoryItem(this.appState, url);
      const currentUrl = window.location.href;
      this.currentHistory.val = getFromHistory(currentUrl);
      window.location.reload();
    } catch (error) {
      console.error("Failed to delete history item:", error);
    }
  };

  private createHistoryItem = (url: string, title: string) => {
    return div(
      { class: "history-item" },
      a(
        {
          href: url,
          class: "history-link",
          onclick: (e: Event) => {
            e.preventDefault();
            window.location.href = url;
            this.remove();
          },
        },
        title
      ),
      button(
        {
          onclick: () => this.handleDeleteHistoryItem(url),
          class: "delete-button",
        },
        "❌"
      )
    );
  };

  private render() {
    if (this.shadowRoot) {
      const content = div(
        { class: "modal-content" },
        div({ class: "title" }, "Translation History"),
        div(
          { style: "margin-bottom: 20px;" },
          Await(
            {
              value: this.currentHistory.val,
              Loading: () => div("Loading translation history..."),
              Error: (error) =>
                div(
                  { style: "color: red;" },
                  "Failed to load history: ",
                  error.message
                ),
            },
            (history) =>
              history
                ? this.createHistoryItem(
                    window.location.href,
                    (history as any)?.title || "Untitled"
                  )
                : div("No translation for current page")
          )
        ),
        div(
          { style: "margin-bottom: 20px;" },
          ...this.appState.history.map((item) =>
            this.createHistoryItem(item.url, item.title)
          )
        ),
        div(
          { class: "button-group" },
          button(
            {
              onclick: () => this.remove(),
              class: "cancel-button",
            },
            "Cancel"
          )
        )
      );

      this.shadowRoot.appendChild(content);
    }
  }
}

customElements.define("settings-modal", SettingsModalElement);
customElements.define("history-modal", HistoryModalElement);

export const settingsModal = (appState: AppState) => {
  const modal = document.createElement(
    "settings-modal"
  ) as SettingsModalElement;
  modal.initialize(appState);
  document.body.appendChild(modal);
};

export const historyModal = (appState: AppState) => {
  const modal = document.createElement("history-modal") as HistoryModalElement;
  modal.initialize(appState);
  document.body.appendChild(modal);
};
</file>

<file path="src/style.css">
.vanui-tab-button .active{
    color: #1989fa;
}
</file>

<file path="src/typescript.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#007ACC" d="M0 128v128h256V0H0z"></path><path fill="#FFF" d="m56.612 128.85l-.081 10.483h33.32v94.68h23.568v-94.68h33.321v-10.28c0-5.69-.122-10.444-.284-10.566c-.122-.162-20.4-.244-44.983-.203l-44.74.122l-.121 10.443Zm149.955-10.742c6.501 1.625 11.459 4.51 16.01 9.224c2.357 2.52 5.851 7.111 6.136 8.208c.08.325-11.053 7.802-17.798 11.988c-.244.162-1.22-.894-2.317-2.52c-3.291-4.795-6.745-6.867-12.028-7.233c-7.76-.528-12.759 3.535-12.718 10.321c0 1.992.284 3.17 1.097 4.795c1.707 3.536 4.876 5.649 14.832 9.956c18.326 7.883 26.168 13.084 31.045 20.48c5.445 8.249 6.664 21.415 2.966 31.208c-4.063 10.646-14.14 17.879-28.323 20.276c-4.388.772-14.79.65-19.504-.203c-10.28-1.828-20.033-6.908-26.047-13.572c-2.357-2.6-6.949-9.387-6.664-9.874c.122-.163 1.178-.813 2.356-1.504c1.138-.65 5.446-3.129 9.509-5.485l7.355-4.267l1.544 2.276c2.154 3.29 6.867 7.801 9.712 9.305c8.167 4.307 19.383 3.698 24.909-1.26c2.357-2.153 3.332-4.388 3.332-7.68c0-2.966-.366-4.266-1.91-6.501c-1.99-2.845-6.054-5.242-17.595-10.24c-13.206-5.69-18.895-9.224-24.096-14.832c-3.007-3.25-5.852-8.452-7.03-12.8c-.975-3.617-1.22-12.678-.447-16.335c2.723-12.76 12.353-21.659 26.25-24.3c4.51-.853 14.994-.528 19.424.569Z"></path></svg>
</file>

<file path="src/utils.ts">
import { addToHistory, } from "./history";
import type { aiProvider } from "./app.d";
export async function getSystemPrompt(){
    let defaultPrompt = `"Bạn là một AI chuyển ngữ văn học chuyên nghiệp. Hãy dịch đoạn văn bản sau sang tiếng Việt với văn phong tự nhiên, đúng ngữ pháp và diễn đạt mượt mà, trôi chảy. Tuân thủ nghiêm ngặt các yêu cầu sau:  
1. Không sử dụng ký tự Trung Quốc (Hán tự) trong bản dịch. Nếu phát hiện ký tự Trung Quốc, thay thế ngay bằng từ tiếng Việt tương đương.  
2. Hạn chế sử dụng từ Hán Việt, chỉ giữ lại các từ phổ biến, dễ hiểu với độc giả hiện đại, đồng thời đảm bảo cách diễn đạt phù hợp với văn phong tiếng Việt hiện đại, mượt mà, tránh lối diễn đạt cứng nhắc hoặc dịch từng từ.  
3. Xử lý tên riêng (nhân vật, địa danh, đồ vật, động thực vật...) như sau:  
   - Giữ nguyên tất cả tên riêng và không thay đổi chúng thành bất kỳ tên nào khác (ví dụ: không thay thế tên riêng bằng "Cức").  
   - Viết hoa chữ cái đầu tiên của tên riêng theo đúng quy tắc tiếng Việt (ví dụ: "Thanh Long", "Diệp Hi", "Hi Thành").  
   - Không dịch nghĩa các tên riêng để bảo toàn tính nguyên bản và ý nghĩa trong ngữ cảnh truyện.  
   - Đảm bảo tính nhất quán: Một khi tên riêng đã được giữ nguyên, hãy sử dụng nguyên bản đó xuyên suốt toàn bộ văn bản.  
   - Ví dụ:  
     - "Tù trưởng Cức" → Giữ nguyên "Tù trưởng Cức" (không dịch thành "Tù trưởng Gai").  
     - "Bộ lạc Cức" → Giữ nguyên "Bộ lạc Cức" (không dịch thành "Bộ lạc Gai").  
4. Trong đối thoại ưu tiên dụng cách xưng hô "ta-ngươi" để phù hợp với bối cảnh cổ đại và phong cách truyện tiên hiệp.  
5. Xử lý góc nhìn nhân vật:  
   - Phân tích ngữ cảnh để lựa chọn phù hợp:  
     - Nếu đối tượng được nhắc đến không phải kẻ thù hoặc mang tính thân thiện/trung lập hoặc không chắc chắn là thù địch, hãy sử dụng "họ" hoặc "bọn họ".  
     - Nếu đối tượng được nhắc đến là kẻ thù hoặc mang tính tiêu cực, hãy sử dụng "bọn nó", "chúng nó", hoặc "chúng".  
   - Ví dụ:  
     - "Bọn họ xây tường thành" → Giữ nguyên "bọn họ" hoặc "họ" nếu đối tượng không phải kẻ thù.  
     - "Bọn họ phá hủy tường thành" → Dịch thành "bọn nó" hoặc "chúng nó" nếu đối tượng là kẻ thù.  
6. Kiểm tra kỹ bản dịch để loại bỏ hoàn toàn ký tự Trung Quốc và lỗi ngữ pháp.  
7. Chỉ cung cấp bản dịch hoàn chỉnh, không thêm tóm tắt, bình luận hay giải thích.  
`
    const response = await fetch('https://gist.githubusercontent.com/sourman-dev/1f8bc4876a5a300105ec657231fbfb30/raw/83244d4e424cc659bfc3f7e6301d4afcdfd0417f/prompt.txt');
    if (response.ok) {
      defaultPrompt = await response.text();
    }
    return defaultPrompt;
}

const finishStream = (data: any) => {
  let isFinish = false;
  let completionMessage = "";
  if (data.candidates && data.candidates[0]) {
    const candidate = data.candidates[0];
    const finishReason = candidate.finishReason !== undefined;
    const tokenCount = data.usageMetadata?.totalTokenCount;
    if (finishReason) {
      completionMessage = "\n[Translation completed]";
      if (tokenCount) {
        completionMessage += `\nTotal tokens used: ${tokenCount}`;
      }
      isFinish = true;
    }
  }
  return {
    isFinish,
    completionMessage,
  };
};

const finalPrompt = (text: string, appState: any) => {
  let systemPrompt = `${appState.settings.systemPrompt}\n`;
  const userPrompt = appState.settings.userPrompt;
  if (userPrompt && userPrompt.length > 0) {
    systemPrompt += `- Các yêu cầu mở rộng này sẽ được bổ sung vào yêu cầu trên:\n${userPrompt}\n`;
  }
  systemPrompt += `Hãy dịch đoạn văn bản sau:\n${text}`;
  return systemPrompt;
};

const geminiCompletions = async (
  text: string,
  onChunk: (chunk: string) => void,
  appState: any
) => {
  const currentProvider = appState.settings.aiProvider.find((p: aiProvider): boolean => p.selected);
  const GeminiKey = currentProvider?.apiKey;
  const modelName = currentProvider?.modelName;
  const ApiURL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:streamGenerateContent`;
  
  const systemPrompt = finalPrompt(text, appState);
  const requestData = {
    contents: [
      {
        role: "user",
        parts: [
          {
            text: systemPrompt,
          },
        ],
      },
    ],
    generationConfig: {
      temperature: appState.settings.aiProvider.temperature || 1.1,
    },
  };

  const requestOptions = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(requestData),
  };

  try {
    const response = await fetch(`${ApiURL}?key=${GeminiKey}`, requestOptions);
    const reader = response.body?.getReader();
    if (!reader) throw new Error("Failed to get stream reader");

    let buffer = "";
    const decoder = new TextDecoder();
    let translatedText = "";
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });

      // Process complete chunks
      let startBrace = buffer.indexOf("{");
      while (startBrace !== -1) {
        let openBraces = 1;
        let currentPos = startBrace + 1;

        while (openBraces > 0 && currentPos < buffer.length) {
          if (buffer[currentPos] === "{") openBraces++;
          if (buffer[currentPos] === "}") openBraces--;
          currentPos++;
        }

        if (openBraces === 0) {
          try {
            const jsonStr = buffer.slice(startBrace, currentPos);
            const data = JSON.parse(jsonStr);

            if (
              data.candidates &&
              data.candidates[0]?.content?.parts[0]?.text
            ) {
              const chunkText = data.candidates[0].content.parts[0].text;
              const { completionMessage, isFinish } = finishStream(data);
              const finalText = chunkText + completionMessage;
              translatedText += finalText;
              if (isFinish) {
                const url = window.location.href;
                const title = document.title;
                await addToHistory(appState, url, title, translatedText);
              }
              onChunk(finalText);
            }

            buffer = buffer.slice(currentPos);
            startBrace = buffer.indexOf("{");
          } catch (e) {
            startBrace = buffer.indexOf("{", startBrace + 1);
          }
        } else {
          break;
        }
      }
    }

    // Handle any remaining complete JSON in the buffer
    if (buffer.trim()) {
      try {
        let startBrace = buffer.indexOf("{");
        if (startBrace !== -1) {
          let openBraces = 1;
          let currentPos = startBrace + 1;

          while (openBraces > 0 && currentPos < buffer.length) {
            if (buffer[currentPos] === "{") openBraces++;
            if (buffer[currentPos] === "}") openBraces--;
            currentPos++;
          }

          if (openBraces === 0) {
            const jsonStr = buffer.slice(startBrace, currentPos);
            const data = JSON.parse(jsonStr);
            if (data.candidates && data.candidates[0]) {
              const candidate = data.candidates[0];
              const { completionMessage, isFinish } = finishStream(data);

              if (candidate.content?.parts[0]?.text) {
                const chunkText = candidate.content.parts[0].text;
                const finalText = chunkText + completionMessage;
                translatedText += finalText;
                if (isFinish) {
                  const url = window.location.href;
                  const title = document.title;
                  await addToHistory(appState, url, title, translatedText);
                }
                onChunk(finalText);
              }
            }
          }
        }
      } catch (e) {
        console.error("Error parsing final chunk:", e);
      }
    }
  } catch (error) {
    console.error("Error:", error);
  }
};

const qwenCompletions = async (
  text: string,
  onChunk: (chunk: string) => void,
  appState: any
) => {
  const systemPrompt = finalPrompt(text, appState);
  const currentProvider = appState.settings.aiProvider.find((p: aiProvider): boolean => p.selected);
  const requestData = {
    stream: true,
    incremental_output: true,
    chat_type: "t2t",
    model: currentProvider?.modelName || "qwen-max-latest",
    messages: [
      {
        role: "user",
        content: systemPrompt,
        chat_type: "t2t",
        extra: {},
        feature_config: {
          thinking_enabled: false
        }
      }
    ],
    session_id: crypto.randomUUID(),
    chat_id:  crypto.randomUUID(),
    id: crypto.randomUUID()
  };

  const requestOptions = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "accept": "*/*",
      "accept-language": "en-US,en;q=0.9,vi;q=0.8",
      "bx-v": "2.5.28",
      "origin": "https://chat.qwen.ai",
      "priority": "u=1, i",
      "referer": "https://chat.qwen.ai",
      "sec-ch-ua": '"Not(A:Brand";v="99", "Google Chrome";v="133", "Chromium";v="133"',
      "sec-ch-ua-mobile": "?0",
      "sec-ch-ua-platform": '"macOS"',
      "sec-fetch-dest": "empty",
      "sec-fetch-mode": "cors",
      "sec-fetch-site": "same-origin",
      "source": "web",
      "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36",
      "x-accel-buffering": "no",
      "Cookie": currentProvider?.apiKey || ""
    },
    body: JSON.stringify(requestData)
  };

  try {
    const response = await fetch("https://chat.qwen.ai/api/chat/completions", requestOptions);
    const reader = response.body?.getReader();
    if (!reader) throw new Error("Failed to get stream reader");

    let buffer = "";
    const decoder = new TextDecoder();
    let translatedText = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");

      for (let i = 0; i < lines.length - 1; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        try {
          const data = JSON.parse(line.replace(/^data: /, ''));
          if (data.choices && data.choices[0]?.delta?.content) {
            const text = data.choices[0].delta.content;
            translatedText += text;
            onChunk(text);
          } else if (data.choices && data.choices[0] && !data.choices[0].delta?.content) {
            // Empty content indicates completion
            const url = window.location.href;
            const title = document.title;
            await addToHistory(appState, url, title, translatedText);
            onChunk("\n[Translation completed]");
            return;
          }
        } catch (e) {
          console.error("Error parsing chunk:", e);
        }
      }

      buffer = lines[lines.length - 1];
    }
  } catch (error) {
    console.error("Error:", error);
    onChunk("\n[Error: Failed to connect to Qwen API]");
  }
};

export const translateFunc = async (
  text: string,
  onChunk: (chunk: string) => void,
  appState: any
) => {
  const isGemini = appState.settings.aiProvider.find((p: aiProvider) => p.selected)?.name === 'Google';
  if (isGemini) {
    return geminiCompletions(text, onChunk, appState);
  } else {
    return qwenCompletions(text, onChunk, appState);
  }
};
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
/// <reference types="vite-plugin-monkey/client" />
//// <reference types="vite-plugin-monkey/global" />
</file>

<file path="src/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="package.json">
{
  "name": "dichtruyen.app",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "terser": "^5.39.0",
    "typescript": "^5.7.2",
    "vite": "^6.0.5",
    "vite-plugin-monkey": "^5.0.3"
  },
  "dependencies": {
    "@mozilla/readability": "^0.6.0",
    "idb-keyval": "^6.2.1",
    "text-vide": "^1.8.1",
    "vanjs-core": "^1.5.3",
    "vanjs-ext": "^0.6.2",
    "vanjs-ui": "^0.11.10"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "noEmit": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
import monkey from 'vite-plugin-monkey';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    monkey({
      entry: 'src/main.ts',
      userscript: {
        icon: 'https://vitejs.dev/logo.svg',
        namespace: 'npm/vite-plugin-monkey',
        match: ['*://*/*'],
      },
    }),
  ],
  build: {
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    },
    rollupOptions: {
      output: {
        manualChunks: undefined,
        compact: true
      }
    }
  }
});
</file>

</files>
